Here’s a quick map of where the bulk of the tracked lines live after excluding docs/ so you can prioritize cleanup:

skills/**: ~72K lines, almost all Markdown playbooks. Decide which skill packs you still need, archive or split into a separate repo if they’re mostly reference. Identify which roles or playbooks are active in current workflows; tag the rest as “legacy” and stage them for export. Consider generating a single canonical template per skill and consolidating redundant reference material into appendices to shrink file counts. If certain packs must stay, create a lightweight index with links instead of embedding full-length guides in the repo.

PHASE_2_SIMPLIFICATION_PLAN.md + other top-level Markdown: ~3–4K lines. If the plan is historical, move it to an archive folder or external doc. Capture any action items that remain relevant and migrate them into a living roadmap doc. For narrative history that should be preserved, publish to a shared knowledge base (e.g., Notion/Confluence) and replace the repo copy with a brief summary plus a link. Flag any Markdown files that mix specs and minutes, and split them so only actionable specifications remain in the main tree.

webapp/**: ~37K lines across TypeScript, tests, and CSS. Prioritize linting/formatting here, trim disabled files (useAsync.ts.disabled etc.), and remove stale deprecated routes. Run `ts-prune` or similar to surface unused exports, and capture a list of files over 400 lines for targeted refactors. Audit `deprecated-routes/` directories—either delete them or replace with stubs that point to the new endpoints. For each large component (e.g., `ChatInterface.tsx`, `workflows.config.ts`), note suspected responsibilities and plan modular splits to unblock incremental cleanup.

integrations/** & scripts/**: ~6K lines. Check for unused integrations or one-off scripts; create an archive/legacy folder for anything no longer executed. Add a quick usage matrix naming the owning team and last confirmed run for every script. For integrations that are not currently enabled in production, document the deprecation path, dependencies, and whether the code can be removed outright. Consider converting ad-hoc scripts into npm tasks or GitHub Actions workflows so they can be versioned and tested.

Tests: ~3K lines in tests/** + webapp/__tests__/ / webapp/e2e/. Confirm which suites still run in CI; drop or move obsolete ones. Compare current CI configuration with the test directories to find gaps. Mark long-running suites (e2e, integration) and decide if they should stay in the main repo or shift to a dedicated QA project. For tests you keep, enforce naming conventions and align fixtures to a shared data folder to avoid drift.

Suggested starting steps:

Inventory & tag: Create a simple spreadsheet or checklist grouping files by type (reference doc, production code, test, deprecated). Mark “keep/retire/maybe”. Attach metadata such as owner, last updated date, and dependency notes so that later decisions are faster. When possible, automate the inventory using `find` + scripts to output CSVs for bulk tagging.

Archive references: Move legacy plans, phase summaries, and skill reference packs you don’t actively edit into a dedicated archive/ or separate repo so they don’t inflate the active workspace. Preserve git history by moving the folders instead of deleting them, and add a README that explains how to retrieve archived material. If storage is a concern, migrate large assets to shared storage (e.g., Drive or S3) and link back.

Review webapp structure: Identify duplicate or disabled components, deprecated routes, and large monolith files (e.g., ChatInterface.tsx, workflows.config.ts). Plan refactors or splits. Build a dependency graph (e.g., `madge`) to spot circular references and components that should be converted into shared libraries. Flag feature areas that could be code-split or lazy-loaded, and record quick wins (renaming, folder reorganizations) versus heavy lifts (state management redesigns).

Automate style checks: Ensure ESLint/Prettier run on commit so future cleanup sticks. Consider pruning unused dependencies in package.json. Evaluate CI coverage for type-checking, linting, and tests, adding missing jobs where needed. Set up dependency review alerts and monthly audits to prevent the repo from accreting unused packages or scripts.

Set guardrails: Add documentation in README.md about what belongs in the repo (and what should live elsewhere) to stay lean after the cleanup. Define a folder policy (e.g., “long-form guides belong in knowledge base”) and socialize it with contributors. Add PR templates or checklists that ask authors to confirm new docs/components follow the policy.

If you want a finer breakdown (e.g., lines per webapp subfolder or only code vs. markdown) let me know, and I can slice it further while you stay in ask mode.